/*!
 * devextreme-vue
 * Version: 23.2.3
 * Build date: Tue Nov 28 2023
 *
 * Copyright (c) 2012 - 2023 Developer Express Inc. ALL RIGHTS RESERVED
 *
 * This software may be modified and distributed under the terms
 * of the MIT license. See the LICENSE file in the root of the project for details.
 *
 * https://github.com/DevExpress/devextreme-vue
 */

"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var vue_1 = require("vue");
var configuration_1 = __importStar(require("../configuration"));
function createRootConfig(updateFunc) {
    return new configuration_1.default(updateFunc, null, {});
}
function createConfigWithExpectedChildren(children) {
    return new configuration_1.default(jest.fn(), null, {}, children);
}
describe('fullPath building', function () {
    var testCases = [
        {
            msg: 'works for null',
            name: null,
            expected: null,
        },
        {
            msg: 'works without owner',
            name: 'abc',
            expected: 'abc',
        },
        {
            msg: 'works with owner',
            name: 'abc',
            ownerPath: 'def',
            expected: 'def.abc',
        },
        {
            msg: 'works for collection item',
            name: 'abc',
            collectionIndex: 123,
            expected: 'abc[123]',
        },
        {
            msg: 'works for collection item with owner',
            name: 'abc',
            ownerPath: 'def',
            collectionIndex: 123,
            expected: 'def.abc[123]',
        },
    ];
    var _loop_1 = function (msg, name_1, collectionIndex, ownerPath, expected) {
        it(msg, function () {
            var isCollection = collectionIndex !== undefined;
            var ownerConfig = ownerPath ? { fullPath: ownerPath } : undefined;
            expect(new configuration_1.default(jest.fn(), name_1, {}, undefined, isCollection, collectionIndex, ownerConfig).fullPath).toBe(expected);
        });
    };
    for (var _i = 0, testCases_1 = testCases; _i < testCases_1.length; _i++) {
        var _a = testCases_1[_i], msg = _a.msg, name_1 = _a.name, collectionIndex = _a.collectionIndex, ownerPath = _a.ownerPath, expected = _a.expected;
        _loop_1(msg, name_1, collectionIndex, ownerPath, expected);
    }
});
it('calls update from nested', function () {
    var callback = jest.fn();
    var root = createRootConfig(callback);
    var nested = root.createNested('option', {});
    nested.updateValue('prop', 123);
    expect(callback).toHaveBeenCalledTimes(1);
    expect(callback).toHaveBeenCalledWith('option.prop', 123);
});
it('calls update from subnested', function () {
    var callback = jest.fn();
    var root = createRootConfig(callback);
    var nested = root.createNested('option', {});
    var subNested = nested.createNested('subOption', {});
    subNested.updateValue('prop', 123);
    expect(callback).toHaveBeenCalledTimes(1);
    expect(callback).toHaveBeenCalledWith('option.subOption.prop', 123);
});
it('calls update from nested collectionItem (first)', function () {
    var callback = jest.fn();
    var root = createRootConfig(callback);
    var nested = root.createNested('option', {}, true);
    root.createNested('option', {}, true);
    nested.updateValue('prop', 123);
    expect(callback).toHaveBeenCalledTimes(1);
    expect(callback).toHaveBeenCalledWith('option[0].prop', 123);
});
it('calls update from nested collectionItem (middle)', function () {
    var callback = jest.fn();
    var root = createRootConfig(callback);
    root.createNested('option', {}, true);
    var nested = root.createNested('option', {}, true);
    root.createNested('option', {}, true);
    nested.updateValue('prop', 123);
    expect(callback).toHaveBeenCalledTimes(1);
    expect(callback).toHaveBeenCalledWith('option[1].prop', 123);
});
it('calls update from nested collectionItem (last)', function () {
    var callback = jest.fn();
    var root = createRootConfig(callback);
    root.createNested('option', {}, true);
    root.createNested('option', {}, true);
    var nested = root.createNested('option', {}, true);
    nested.updateValue('prop', 123);
    expect(callback).toHaveBeenCalledTimes(1);
    expect(callback).toHaveBeenCalledWith('option[2].prop', 123);
});
it('calls update from nested collectionItem (the only)', function () {
    var callback = jest.fn();
    var root = createRootConfig(callback);
    var nested = root.createNested('option', {}, true);
    nested.updateValue('prop', 123);
    expect(callback).toHaveBeenCalledTimes(1);
    expect(callback).toHaveBeenCalledWith('option[0].prop', 123);
});
it('binds option watchers', function () {
    var updateValueFunc = jest.fn();
    var $watchFunc = jest.fn();
    var innerChanges = {};
    configuration_1.bindOptionWatchers({
        updateValue: updateValueFunc,
        getOptionsToWatch: function () { return ['prop1']; },
        innerChanges: {},
    }, {
        $watch: $watchFunc,
    }, innerChanges);
    expect($watchFunc.mock.calls[0][0]).toBe('prop1');
    var value = {};
    $watchFunc.mock.calls[0][1](value);
    expect(updateValueFunc).toHaveBeenCalledTimes(1);
    expect(updateValueFunc.mock.calls[0][0]).toBe('prop1');
    expect(updateValueFunc.mock.calls[0][1]).toBe(value);
});
it('should update only when raw value not equal', function () {
    var updateValueFunc = jest.fn();
    var $watchFunc = jest.fn();
    var innerChanges = { prop1: 'test' };
    configuration_1.bindOptionWatchers({
        updateValue: updateValueFunc,
        getOptionsToWatch: function () { return ['prop1']; },
        innerChanges: {},
    }, {
        $watch: $watchFunc,
    }, innerChanges);
    $watchFunc.mock.calls[0][1](vue_1.reactive(innerChanges).prop1);
    expect(updateValueFunc).toHaveBeenCalledTimes(0);
    $watchFunc.mock.calls[0][1](vue_1.reactive({ prop1: 'test1' }).prop1);
    expect(updateValueFunc).toHaveBeenCalledTimes(1);
    expect(updateValueFunc.mock.calls[0][0]).toBe('prop1');
    expect(updateValueFunc.mock.calls[0][1]).toBe('test1');
});
describe('initial configuration', function () {
    it('pulls value from nested', function () {
        var root = createRootConfig(jest.fn());
        var nested = root.createNested('option', {});
        nested
            .createNested('subOption', { prop: 123 })
            .init(['prop']);
        expect(root.getNestedOptionValues()).toMatchObject({
            option: {
                subOption: {
                    prop: 123,
                },
            },
        });
    });
    it('pulls array of values from a coollectionItem nested (single value)', function () {
        var root = createRootConfig(jest.fn());
        root.createNested('options', { propA: 123 }, true);
        expect(root.getNestedOptionValues()).toMatchObject({
            options: [
                { propA: 123 },
            ],
        });
    });
    it('pulls array of values from a coollectionItem nested (several values)', function () {
        var root = createRootConfig(jest.fn());
        root.createNested('options', { propA: 123 }, true);
        root.createNested('options', { propA: 456, propB: 789 }, true);
        expect(root.getNestedOptionValues()).toMatchObject({
            options: [
                { propA: 123 },
                { propA: 456, propB: 789 },
            ],
        });
    });
    it('pulls values from the last nested (not a coollectionItem)', function () {
        var root = createRootConfig(jest.fn());
        root.createNested('option', { propA: 123 });
        root.createNested('option', { propA: 456, propB: 789 });
        expect(root.getNestedOptionValues()).toMatchObject({
            option: { propA: 456, propB: 789 },
        });
    });
    it('pulls values from self and nested', function () {
        var root = new configuration_1.default(jest.fn(), null, { propA: 123 });
        var nested = root.createNested('option', { propB: 456 });
        nested.createNested('subOption', { propC: 789 });
        expect(root.getNestedOptionValues()).toMatchObject({
            option: {
                propB: 456,
                subOption: {
                    propC: 789,
                },
            },
        });
        expect(root.initialValues).toMatchObject({
            propA: 123,
        });
    });
    it('pulls empty value for correct option structure T728446', function () {
        var root = createRootConfig(jest.fn());
        var nested = root.createNested('option', {}, true);
        nested.createNested('subOption', {});
        expect(root.getNestedOptionValues()).toMatchObject({ option: [{ subOption: {} }] });
    });
    it('pulls values and ignores empty nested', function () {
        var root = createRootConfig(jest.fn());
        var nested = root.createNested('option', {});
        nested.init(['empty']);
        nested
            .createNested('subOption', { prop: 123 })
            .init(['prop']);
        root.createNested('anotherOption', {});
        nested.createNested('anotherSubOption', {});
        expect(root.getNestedOptionValues()).toMatchObject({
            option: {
                subOption: {
                    prop: 123,
                },
            },
        });
    });
});
describe('collection items creation', function () {
    describe('not-expected item .isCollectionItem prop', function () {
        it('is true if isCollection arg is true', function () {
            var owner = new configuration_1.default(jest.fn(), null, {});
            var nested = owner.createNested('name', {}, true);
            expect(nested.isCollectionItem).toBeTruthy();
        });
        it('is false if isCollection arg is false', function () {
            var owner = new configuration_1.default(jest.fn(), null, {});
            var nested = owner.createNested('name', {}, false);
            expect(nested.isCollectionItem).toBeFalsy();
        });
        it('is false if isCollection arg is undefined', function () {
            var owner = new configuration_1.default(jest.fn(), null, {});
            var nested = owner.createNested('name', {});
            expect(nested.isCollectionItem).toBeFalsy();
        });
    });
    describe('expectation of collection item', function () {
        it('applied if isCollection arg is true', function () {
            var owner = createConfigWithExpectedChildren({ abc: { isCollectionItem: true, optionName: 'def' } });
            var nested = owner.createNested('abc', {}, true);
            expect(nested.isCollectionItem).toBeTruthy();
            expect(nested.name).toBe('def');
        });
        it('applied if isCollection arg is false', function () {
            var owner = createConfigWithExpectedChildren({ abc: { isCollectionItem: true, optionName: 'def' } });
            var nested = owner.createNested('abc', {}, false);
            expect(nested.isCollectionItem).toBeTruthy();
            expect(nested.name).toBe('def');
        });
        it('applied if isCollection arg is undefined', function () {
            var owner = createConfigWithExpectedChildren({ abc: { isCollectionItem: true, optionName: 'def' } });
            var nested = owner.createNested('abc', {});
            expect(nested.isCollectionItem).toBeTruthy();
            expect(nested.name).toBe('def');
        });
    });
    describe('expected as collection item .isCollectionItem prop', function () {
        it('is true if isCollection arg is true', function () {
            var owner = createConfigWithExpectedChildren({ abc: { isCollectionItem: false, optionName: 'def' } });
            var nested = owner.createNested('abc', {}, true);
            expect(nested.isCollectionItem).toBeFalsy();
        });
        it('is true if isCollection arg is false', function () {
            var owner = createConfigWithExpectedChildren({ abc: { isCollectionItem: false, optionName: 'def' } });
            var nested = owner.createNested('abc', {}, false);
            expect(nested.isCollectionItem).toBeFalsy();
        });
        it('is true if isCollection arg is undefined', function () {
            var owner = createConfigWithExpectedChildren({ abc: { isCollectionItem: false, optionName: 'def' } });
            var nested = owner.createNested('abc', {});
            expect(nested.isCollectionItem).toBeFalsy();
            expect(nested.name).toBe('def');
        });
    });
});
describe('options watch-list', function () {
    it('includes option with initial values', function () {
        var config = new configuration_1.default(jest.fn(), null, { option1: 123, option2: 456 });
        config.init(['option1']);
        expect(config.getOptionsToWatch()).toEqual(['option1']);
    });
    it('includes option without initial values', function () {
        var config = new configuration_1.default(jest.fn(), null, {});
        config.init(['option1']);
        expect(config.getOptionsToWatch()).toEqual(['option1']);
    });
    it('excludes option if finds nested config with the same name', function () {
        var config = new configuration_1.default(jest.fn(), null, {});
        config.init(['option1', 'theNestedOption']);
        config.createNested('theNestedOption', {});
        expect(config.getOptionsToWatch()).toEqual(['option1']);
    });
});
describe('onOptionChanged', function () {
    [
        {
            fullName: 'option',
            value: 'new value',
            previousValue: 'old value',
            component: null,
        },
        {
            fullName: 'option.nestedOption.subNestedOption',
            value: 'any value',
            previousValue: 'old value',
            component: { option: function (name) { return name === 'option' && 'new value'; } },
        },
        {
            fullName: 'option[0]',
            value: 'any value',
            previousValue: 'old value',
            component: { option: function (name) { return name === 'option' && 'new value'; } },
        },
        {
            fullName: 'option[0].nestedOption',
            value: 'any value',
            previousValue: 'old value',
            component: { option: function (name) { return name === 'option' && 'new value'; } },
        },
    ].map(function (optionChangedArgs) {
        it('emits from root configuration', function () {
            var innerChanges = {};
            var emitStub = jest.fn();
            var config = new configuration_1.default(jest.fn(), null, {});
            var component = {
                $emit: emitStub,
                $props: { option: undefined },
                $options: {
                    props: {
                        option: undefined,
                    },
                },
            };
            configuration_1.setEmitOptionChangedFunc(config, component, innerChanges);
            config.onOptionChanged(optionChangedArgs);
            expect(emitStub).toHaveBeenCalledTimes(1);
            expect(emitStub).toHaveBeenCalledWith('update:option', 'new value');
            expect(innerChanges).toEqual({ option: 'new value' });
        });
    });
    [
        {
            fullName: 'option.nestedOption',
            value: 'new value',
            previousValue: 'old value',
            component: null,
        },
        {
            fullName: 'option.nestedOption.subNestedOption',
            value: 'any value',
            previousValue: 'old value',
            component: { option: function (name) { return name === 'option.nestedOption' && 'new value'; } },
        },
    ].map(function (optionChangedArgs) {
        it('emits from nested configuration', function () {
            var innerChanges = {};
            var emitStub = jest.fn();
            var config = new configuration_1.default(jest.fn(), null, {});
            var nestedConfig = config.createNested('option', {});
            var component = {
                $emit: emitStub,
                $props: { nestedOption: undefined },
                $options: {
                    props: {
                        nestedOption: undefined,
                    },
                },
            };
            configuration_1.setEmitOptionChangedFunc(nestedConfig, component, innerChanges);
            config.onOptionChanged(optionChangedArgs);
            expect(emitStub).toHaveBeenCalledTimes(1);
            expect(emitStub).toHaveBeenCalledWith('update:nestedOption', 'new value');
            expect(innerChanges).toEqual({ nestedOption: 'new value' });
        });
    });
    [
        {
            fullName: 'option[0].nestedOption',
            value: 'new value',
            previousValue: 'old value',
            component: null,
        },
        {
            fullName: 'option[0].nestedOption.subNestedOption',
            value: 'any value',
            previousValue: 'old value',
            component: { option: function (name) { return name === 'option[0].nestedOption' && 'new value'; } },
        },
    ].map(function (optionChangedArgs) {
        it('emits from nested collection configuration', function () {
            var innerChanges = {};
            var emitStub = jest.fn();
            var config = new configuration_1.default(jest.fn(), null, {});
            var nestedConfig = config.createNested('option', {}, true);
            var component = {
                $emit: emitStub,
                $props: { nestedOption: undefined },
                $options: {
                    props: {
                        nestedOption: undefined,
                    },
                },
            };
            configuration_1.setEmitOptionChangedFunc(nestedConfig, component, innerChanges);
            config.onOptionChanged(optionChangedArgs);
            expect(emitStub).toHaveBeenCalledTimes(1);
            expect(emitStub).toHaveBeenCalledWith('update:nestedOption', 'new value');
            expect(innerChanges).toEqual({ nestedOption: 'new value' });
        });
    });
    [
        {
            fullName: 'option',
            value: 'value',
            previousValue: 'value',
            component: null,
        },
        {
            fullName: 'option',
            value: [],
            previousValue: [],
            component: null,
        },
    ].map(function (optionChangedArgs) {
        it('does not emit', function () {
            var innerChanges = {};
            var emitStub = jest.fn();
            var config = new configuration_1.default(jest.fn(), null, {});
            var component = {
                $: {},
                $emit: emitStub,
                $props: {},
                $options: {},
            };
            configuration_1.setEmitOptionChangedFunc(config, component, innerChanges);
            config.onOptionChanged(optionChangedArgs);
            expect(emitStub).toHaveBeenCalledTimes(0);
        });
    });
    // https://github.com/DevExpress/devextreme-vue/issues/330
    it('emits once', function () {
        var emitStubRoot = jest.fn();
        var emitStubNested = jest.fn();
        var component = {
            $: {},
            $emit: emitStubRoot,
            $props: { option: undefined },
            $options: {
                props: {
                    option: undefined,
                },
            },
        };
        var config = new configuration_1.default(jest.fn(), null, {});
        configuration_1.setEmitOptionChangedFunc(config, component, {});
        var nestedConfig1 = config.createNested('option', {}, true);
        configuration_1.setEmitOptionChangedFunc(nestedConfig1, component, {});
        var subNestedConfig = nestedConfig1.createNested('option', {}, false);
        configuration_1.setEmitOptionChangedFunc(subNestedConfig, component, {});
        var nestedConfig2 = config.createNested('option', {}, true);
        configuration_1.setEmitOptionChangedFunc(nestedConfig2, component, {});
        config.onOptionChanged({
            fullName: 'option', value: 'new value', previousValue: 'old value', component: null,
        });
        expect(emitStubRoot).toHaveBeenCalledTimes(1);
        expect(emitStubNested).toHaveBeenCalledTimes(0);
    });
    it('shouldn\'t emit if component does\'t have the prop', function () {
        var emitStubRoot = jest.fn();
        var config = new configuration_1.default(jest.fn(), null, {});
        var component = {
            $emit: emitStubRoot,
            $props: { option: undefined },
            $options: {
                props: {
                    option: undefined,
                },
            },
        };
        configuration_1.setEmitOptionChangedFunc(config, component, {});
        config.onOptionChanged({
            fullName: 'wrongName',
            value: 'new value',
            previousValue: 'old value',
            component: null,
        });
        expect(emitStubRoot).toHaveBeenCalledTimes(0);
    });
});
