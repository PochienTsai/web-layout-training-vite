/*!
 * devextreme-vue
 * Version: 23.2.3
 * Build date: Tue Nov 28 2023
 *
 * Copyright (c) 2012 - 2023 Developer Express Inc. ALL RIGHTS RESERVED
 *
 * This software may be modified and distributed under the terms
 * of the MIT license. See the LICENSE file in the root of the project for details.
 *
 * https://github.com/DevExpress/devextreme-vue
 */

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
import { mount } from '@vue/test-utils';
import * as events from 'devextreme/events';
import { createVNode, defineComponent, h, nextTick, renderSlot, } from 'vue';
import { createRouter, createWebHistory } from 'vue-router';
import { pullConfigComponents } from '../children-processing';
import globalConfig from '../config';
import Configuration from '../configuration';
import { createComponent, createConfigurationComponent, createExtensionComponent } from '../index';
import { getNodeOptions } from '../vue-helper';
var eventHandlers = {};
var Widget = {
    option: jest.fn(),
    resetOption: jest.fn(),
    dispose: jest.fn(),
    on: function (event, handler) {
        eventHandlers[event] = handler;
    },
    fire: function (event, args) {
        if (!eventHandlers[event]) {
            throw new Error("no handler registered for '" + event + "'");
        }
        eventHandlers[event](args);
    },
    beginUpdate: jest.fn(),
    endUpdate: jest.fn(),
};
var CustomPlugin = {
    install: function (app) {
        app.test = 'test data';
    },
};
function createWidget(_, options) {
    if (options.onInitializing) {
        options.onInitializing.call(Widget);
    }
    return Widget;
}
var WidgetClass = jest.fn(createWidget);
var TestComponent = createComponent({
    beforeCreate: function () {
        this.$_WidgetClass = WidgetClass;
        this.$_hasAsyncTemplate = true;
    },
    props: {
        prop1: Number,
        prop2: Array,
        sampleProp: String,
        templateName: String,
    },
    model: {
        prop: 'prop1',
        event: 'update:prop1',
    },
});
function skipIntegrationOptions(options) {
    var result = __assign({}, options);
    delete result.integrationOptions;
    delete result.onInitializing;
    delete result.ref;
    delete result.id;
    return result;
}
function buildTestConfigCtor() {
    return createConfigurationComponent({
        props: {
            prop1: Number,
            prop2: String,
            sampleProp: String,
        },
    });
}
jest.setTimeout(1000);
beforeEach(function () {
    jest.clearAllMocks();
});
describe('component rendering', function () {
    it('correctly renders', function () {
        var wrapper = mount(TestComponent);
        expect(wrapper.html()).toBe('<div></div>');
    });
    it('calls widget creation', function () {
        mount(TestComponent);
        expect(WidgetClass).toHaveBeenCalledTimes(1);
        expect(Widget.beginUpdate).toHaveBeenCalledTimes(1);
        expect(Widget.endUpdate).toHaveBeenCalledTimes(1);
    });
    it('passes id to element', function () {
        var vm = defineComponent({
            template: '<test-component id=\'my-id\'/>',
            components: {
                TestComponent: TestComponent,
            },
        });
        var wrapper = mount(vm);
        expect(wrapper.element.id).toBe('my-id');
    });
    it('passes class to element', function () {
        var vm = defineComponent({
            template: '<test-component class=\'my-class my-class2\'/>',
            components: {
                TestComponent: TestComponent,
            },
        });
        var wrapper = mount(vm);
        expect(wrapper.element.className).toBe('my-class my-class2');
    });
    it('passes styles to element', function () {
        var vm = defineComponent({
            template: '<test-component style=\'height: 10px; width: 20px;\'/>',
            components: {
                TestComponent: TestComponent,
            },
        });
        var wrapper = mount(vm);
        expect(wrapper.element.outerHTML).toBe('<div style="height: 10px; width: 20px;"></div>');
    });
    it('creates nested component', function () {
        mount(defineComponent({
            template: '<test-component><test-component/></test-component>',
            components: {
                TestComponent: TestComponent,
            },
        }));
        expect(WidgetClass.mock.instances.length).toBe(2);
        expect(WidgetClass.mock.instances[1]).toEqual({});
    });
    describe('options', function () {
        it('watch prop changing to undefined', function (done) {
            var wrapper = mount(TestComponent, {
                props: {
                    sampleProp: 'test',
                },
            });
            wrapper.vm.$_config.updateValue = jest.fn();
            wrapper.setProps({ sampleProp: undefined });
            nextTick(function () {
                expect(wrapper.vm.$_config.updateValue).toBeCalled();
                done();
            });
        });
        it('pass the same template name as in props', function () {
            var vm = defineComponent({
                template: "<test-component id=\"component\" templateName=\"myTemplate\">\n                        <template #myTemplate>\n                            content\n                        </template>\n                    </test-component>",
                components: {
                    TestComponent: TestComponent,
                },
            });
            var wrapper = mount(vm);
            var component = wrapper.getComponent('#component');
            expect(WidgetClass.mock.calls[0][0]).toBe(component.vm.$el);
            expect(skipIntegrationOptions(WidgetClass.mock.calls[0][1])).toEqual({
                templateName: 'myTemplate',
                templatesRenderAsynchronously: true,
            });
        });
        it('pass template name as default', function () {
            var vm = defineComponent({
                template: "<test-component id=\"component\">\n                        <template #templateName>\n                            content\n                        </template>\n                    </test-component>",
                components: {
                    TestComponent: TestComponent,
                },
            });
            var wrapper = mount(vm);
            var component = wrapper.getComponent('#component');
            expect(WidgetClass.mock.calls[0][0]).toBe(component.vm.$el);
            expect(skipIntegrationOptions(WidgetClass.mock.calls[0][1])).toEqual({
                templateName: 'templateName',
                templatesRenderAsynchronously: true,
            });
        });
        it('pass props to option on mounting', function () {
            var wrapper = mount(TestComponent, {
                props: {
                    sampleProp: 'default',
                },
            });
            expect(WidgetClass.mock.calls[0][0]).toBe(wrapper.element);
            expect(skipIntegrationOptions(WidgetClass.mock.calls[0][1])).toEqual({
                sampleProp: 'default',
                templatesRenderAsynchronously: true,
            });
        });
        it('subscribes to optionChanged', function () {
            mount(TestComponent, {
                props: {
                    sampleProp: 'default',
                },
            });
            expect(eventHandlers).toHaveProperty('optionChanged');
        });
        it('watch prop changing', function () { return __awaiter(void 0, void 0, void 0, function () {
            var wrapper;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        wrapper = mount(TestComponent, {
                            props: {
                                sampleProp: 'default',
                            },
                        });
                        return [4 /*yield*/, wrapper.setProps({ sampleProp: 'new' })];
                    case 1:
                        _a.sent();
                        expect(Widget.option).toHaveBeenCalledTimes(1);
                        expect(Widget.option).toHaveBeenCalledWith('sampleProp', 'new');
                        return [2 /*return*/];
                }
            });
        }); });
        it('component shouldn\'t update array value(by default)', function (done) { return __awaiter(void 0, void 0, void 0, function () {
            var component, wrapper;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        component = defineComponent({
                            template: "\n                    <button @click=\"testData.push(2)\">Click me</button>\n                    <test-component :prop2=\"testData\"></test-component>\n                ",
                            components: {
                                TestComponent: TestComponent,
                            },
                            data: function () {
                                return {
                                    testData: [1],
                                };
                            },
                        });
                        wrapper = mount(component);
                        return [4 /*yield*/, wrapper.find('button').trigger('click')];
                    case 1:
                        _a.sent();
                        nextTick(function () {
                            expect(Widget.option).toHaveBeenCalledTimes(0);
                            done();
                        });
                        return [2 /*return*/];
                }
            });
        }); });
        it('component updates array value if the deepWatch flag equal true', function (done) { return __awaiter(void 0, void 0, void 0, function () {
            var component, wrapper;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        globalConfig({ deepWatch: true });
                        component = defineComponent({
                            template: "\n                    <button @click=\"testData.push(2)\">Click me</button>\n                    <test-component :prop2=\"testData\"></test-component>\n                ",
                            components: {
                                TestComponent: TestComponent,
                            },
                            data: function () {
                                return {
                                    testData: [1],
                                };
                            },
                        });
                        wrapper = mount(component);
                        return [4 /*yield*/, wrapper.find('button').trigger('click')];
                    case 1:
                        _a.sent();
                        nextTick(function () {
                            expect(Widget.option).toHaveBeenCalledTimes(1);
                            expect(Widget.option).toHaveBeenCalledWith('prop2', [1, 2]);
                            globalConfig({ deepWatch: false });
                            done();
                        });
                        return [2 /*return*/];
                }
            });
        }); });
    });
    describe('configuration', function () {
        var Nested = buildTestConfigCtor();
        Nested.$_optionName = 'nestedOption';
        it('creates configuration', function () {
            var wrapper = mount(TestComponent);
            expect(wrapper.vm.$_config).not.toBeNull();
        });
        it('updates pendingOptions from a widget component configuration updateFunc', function () {
            var wrapper = mount(TestComponent);
            var pendingOptions = wrapper.vm.$_pendingOptions;
            var name = 'abc';
            var value = {};
            wrapper.vm.$_config.updateFunc(name, value);
            expect(pendingOptions[name]).toEqual(value);
        });
        it('initializes nested config', function () {
            var vm = defineComponent({
                template: '<test-component id="component">'
                    + '  <nested :prop1="123" />'
                    + '</test-component>',
                components: {
                    TestComponent: TestComponent,
                    Nested: Nested,
                },
            });
            var wrapper = mount(vm);
            var config = wrapper.getComponent('#component').vm.$_config;
            expect(config.nested).toHaveLength(1);
            expect(config.nested[0].name).toBe('nestedOption');
            expect(config.nested[0].options).toEqual(['prop1', 'prop2', 'sampleProp']);
            expect(config.nested[0].initialValues).toEqual({ prop1: 123 });
            expect(config.nested[0].isCollectionItem).toBeFalsy();
        });
        it('initializes nested config (collectionItem)', function () {
            var NestedCollectionItem = buildTestConfigCtor();
            NestedCollectionItem.$_optionName = 'nestedOption';
            NestedCollectionItem.$_isCollectionItem = true;
            var vm = defineComponent({
                template: '<test-component id="component">'
                    + '  <nested-collection-item :prop1="123" />'
                    + '</test-component>',
                components: {
                    TestComponent: TestComponent,
                    NestedCollectionItem: NestedCollectionItem,
                },
            });
            var wrapper = mount(vm);
            var config = wrapper.getComponent('#component').vm.$_config;
            expect(config.nested).toHaveLength(1);
            expect(config.nested[0].name).toBe('nestedOption');
            expect(config.nested[0].options).toEqual(['prop1', 'prop2', 'sampleProp']);
            expect(config.nested[0].initialValues).toEqual({ prop1: 123 });
            expect(config.nested[0].isCollectionItem).toBeTruthy();
            expect(config.nested[0].collectionItemIndex).toBe(0);
        });
        it('initializes nested config (several collectionItems)', function () {
            var NestedCollectionItem = buildTestConfigCtor();
            NestedCollectionItem.$_optionName = 'nestedOption';
            NestedCollectionItem.$_isCollectionItem = true;
            var vm = defineComponent({
                template: '<test-component id="component">'
                    + '  <nested-collection-item :prop1="123" />'
                    + '  <nested-collection-item :prop1="456" prop2="abc" sample-prop="test" />'
                    + '  <nested-collection-item prop2="def" />'
                    + '</test-component>',
                components: {
                    TestComponent: TestComponent,
                    NestedCollectionItem: NestedCollectionItem,
                },
            });
            var wrapper = mount(vm);
            var config = wrapper.getComponent('#component').vm.$_config;
            expect(config.nested).toHaveLength(3);
            expect(config.nested[0].name).toBe('nestedOption');
            expect(config.nested[0].options).toEqual(['prop1', 'prop2', 'sampleProp']);
            expect(config.nested[0].initialValues).toEqual({ prop1: 123 });
            expect(config.nested[0].isCollectionItem).toBeTruthy();
            expect(config.nested[0].collectionItemIndex).toBe(0);
            expect(config.nested[1].name).toBe('nestedOption');
            expect(config.nested[1].options).toEqual(['prop1', 'prop2', 'sampleProp']);
            expect(config.nested[1].initialValues).toEqual({ prop1: 456, prop2: 'abc', sampleProp: 'test' });
            expect(config.nested[1].isCollectionItem).toBeTruthy();
            expect(config.nested[1].collectionItemIndex).toBe(1);
            expect(config.nested[2].name).toBe('nestedOption');
            expect(config.nested[2].options).toEqual(['prop1', 'prop2', 'sampleProp']);
            expect(config.nested[2].initialValues).toEqual({ prop2: 'def' });
            expect(config.nested[2].isCollectionItem).toBeTruthy();
            expect(config.nested[2].collectionItemIndex).toBe(2);
        });
        it('initializes nested config (using v-for)', function () {
            var NestedCollectionItem = buildTestConfigCtor();
            NestedCollectionItem.$_optionName = 'nestedOption';
            NestedCollectionItem.$_isCollectionItem = true;
            var vm = defineComponent({
                template: '<test-component id="component">'
                    + '  <nested-collection-item v-for="(item, index) in items" :key="index" :prop1="item.value" />'
                    + '</test-component>',
                data: function () {
                    return {
                        items: [{ value: 123 }, { value: 321 }, { value: 432 }],
                    };
                },
                components: {
                    TestComponent: TestComponent,
                    NestedCollectionItem: NestedCollectionItem,
                },
            });
            var wrapper = mount(vm);
            var config = wrapper.getComponent('#component').vm.$_config;
            expect(config.nested).toHaveLength(3);
            expect(config.nested[0].name).toBe('nestedOption');
            expect(config.nested[0].options).toEqual(['prop1', 'prop2', 'sampleProp']);
            expect(config.nested[0].initialValues).toEqual({ key: 0, prop1: 123 });
            expect(config.nested[0].isCollectionItem).toBeTruthy();
            expect(config.nested[0].collectionItemIndex).toBe(0);
            expect(config.nested[1].name).toBe('nestedOption');
            expect(config.nested[1].options).toEqual(['prop1', 'prop2', 'sampleProp']);
            expect(config.nested[1].initialValues).toEqual({ key: 1, prop1: 321 });
            expect(config.nested[1].isCollectionItem).toBeTruthy();
            expect(config.nested[1].collectionItemIndex).toBe(1);
            expect(config.nested[2].name).toBe('nestedOption');
            expect(config.nested[2].options).toEqual(['prop1', 'prop2', 'sampleProp']);
            expect(config.nested[2].initialValues).toEqual({ key: 2, prop1: 432 });
            expect(config.nested[2].isCollectionItem).toBeTruthy();
            expect(config.nested[2].collectionItemIndex).toBe(2);
        });
        it('shouldn\'t add fragment as children (v-for)', function () {
            var NestedCollectionItem = buildTestConfigCtor();
            NestedCollectionItem.$_optionName = 'nestedOption';
            NestedCollectionItem.$_isCollectionItem = true;
            var vm = defineComponent({
                template: '<test-component id="component">'
                    + '  <nested-collection-item v-for="(item, index) in items" :key="index" :prop1="item.value" />'
                    + '</test-component>',
                data: function () {
                    return {
                        items: [{ value: 123 }, { value: 321 }, { value: 432 }],
                    };
                },
                components: {
                    TestComponent: TestComponent,
                    NestedCollectionItem: NestedCollectionItem,
                },
            });
            var wrapper = mount(vm);
            var component = wrapper.getComponent('#component').vm;
            expect(component.$.subTree.children).toHaveLength(3);
        });
        it('should find nested options if they wrapped to some kind of fragment elements', function () {
            var NestedCollectionItem = buildTestConfigCtor();
            NestedCollectionItem.$_optionName = 'nestedOption';
            NestedCollectionItem.$_isCollectionItem = true;
            var vm = defineComponent({
                template: "<test-component id=\"component\">\n                        <template v-if=\"hasNested\">\n                            <template v-for=\"(item, index) in items\">\n                                <nested-collection-item :prop1=\"item.value\" />\n                            </template>\n                        </template>\n                    </test-component>",
                data: function () {
                    return {
                        hasNested: true,
                        items: [{ value: 123 }, { value: 321 }, { value: 432 }],
                    };
                },
                components: {
                    TestComponent: TestComponent,
                    NestedCollectionItem: NestedCollectionItem,
                },
            });
            var wrapper = mount(vm);
            var component = wrapper.getComponent('#component').vm;
            expect(component.$.subTree.children).toHaveLength(3);
        });
        it('initializes nested config predefined prop', function () {
            var predefinedValue = {};
            var NestedWithPredefined = buildTestConfigCtor();
            NestedWithPredefined.$_optionName = 'nestedOption';
            NestedWithPredefined.$_predefinedProps = {
                predefinedProp: predefinedValue,
            };
            var vm = defineComponent({
                template: '<test-component id="component">'
                    + '  <nested-with-predefined />'
                    + '</test-component>',
                components: {
                    TestComponent: TestComponent,
                    NestedWithPredefined: NestedWithPredefined,
                },
            });
            var wrapper = mount(vm);
            var config = wrapper.getComponent('#component').vm.$_config;
            var initialValues = config.getNestedOptionValues();
            expect(initialValues).toHaveProperty('nestedOption');
            expect(initialValues.nestedOption).toHaveProperty('predefinedProp');
            expect(initialValues.nestedOption.predefinedProp).toBe(predefinedValue);
        });
        it('initializes sub-nested config', function () {
            var SubNested = buildTestConfigCtor();
            SubNested.$_optionName = 'subNestedOption';
            var vm = defineComponent({
                template: '<test-component id="component">'
                    + '  <nested :prop1="123">'
                    + '    <sub-nested prop2="abc"/>'
                    + '  </nested>'
                    + '</test-component>',
                components: {
                    TestComponent: TestComponent,
                    Nested: Nested,
                    SubNested: SubNested,
                },
            });
            var wrapper = mount(vm);
            var config = wrapper.getComponent('#component').vm.$_config;
            expect(config.nested).toHaveLength(1);
            var nestedConfig = config.nested[0];
            expect(nestedConfig.nested).toHaveLength(1);
            expect(nestedConfig.nested[0].name).toBe('subNestedOption');
            expect(nestedConfig.nested[0].options).toEqual(['prop1', 'prop2', 'sampleProp']);
            expect(nestedConfig.nested[0].initialValues).toEqual({ prop2: 'abc' });
            expect(nestedConfig.nested[0].isCollectionItem).toBeFalsy();
        });
        it('initializes sub-nested config (collectionItem)', function () {
            var SubNested = buildTestConfigCtor();
            SubNested.$_optionName = 'subNestedOption';
            SubNested.$_isCollectionItem = true;
            var vm = defineComponent({
                template: '<test-component id="component">'
                    + '  <nested :prop1="123">'
                    + '    <sub-nested prop2="abc"/>'
                    + '  </nested>'
                    + '</test-component>',
                components: {
                    TestComponent: TestComponent,
                    Nested: Nested,
                    SubNested: SubNested,
                },
            });
            var wrapper = mount(vm);
            var config = wrapper.getComponent('#component').vm.$_config;
            expect(config.nested).toHaveLength(1);
            var nestedConfig = config.nested[0];
            expect(nestedConfig.nested).toHaveLength(1);
            expect(nestedConfig.nested[0].name).toBe('subNestedOption');
            expect(nestedConfig.nested[0].options).toEqual(['prop1', 'prop2', 'sampleProp']);
            expect(nestedConfig.nested[0].initialValues).toEqual({ prop2: 'abc' });
            expect(nestedConfig.nested[0].isCollectionItem).toBeTruthy();
            expect(nestedConfig.nested[0].collectionItemIndex).toBe(0);
        });
        it('initializes sub-nested config (multiple collectionItems)', function () {
            var NestedCollectionItem = buildTestConfigCtor();
            NestedCollectionItem.$_optionName = 'subNestedOption';
            NestedCollectionItem.$_isCollectionItem = true;
            var vm = defineComponent({
                template: '<test-component id="component">'
                    + '  <nested>'
                    + '    <nested-collection-item :prop1="123" />'
                    + '    <nested-collection-item :prop1="456" prop2="abc" />'
                    + '    <nested-collection-item prop2="def" />'
                    + '  </nested>'
                    + '</test-component>',
                components: {
                    TestComponent: TestComponent,
                    Nested: Nested,
                    NestedCollectionItem: NestedCollectionItem,
                },
            });
            var wrapper = mount(vm);
            var config = wrapper.getComponent('#component').vm.$_config;
            expect(config.nested).toHaveLength(1);
            var nestedConfig = config.nested[0];
            expect(nestedConfig.nested).toHaveLength(3);
            expect(nestedConfig.nested[0].name).toBe('subNestedOption');
            expect(nestedConfig.nested[0].options).toEqual(['prop1', 'prop2', 'sampleProp']);
            expect(nestedConfig.nested[0].initialValues).toEqual({ prop1: 123 });
            expect(nestedConfig.nested[0].isCollectionItem).toBeTruthy();
            expect(nestedConfig.nested[0].collectionItemIndex).toBe(0);
            expect(nestedConfig.nested[1].name).toBe('subNestedOption');
            expect(nestedConfig.nested[1].options).toEqual(['prop1', 'prop2', 'sampleProp']);
            expect(nestedConfig.nested[1].initialValues).toEqual({ prop1: 456, prop2: 'abc' });
            expect(nestedConfig.nested[1].isCollectionItem).toBeTruthy();
            expect(nestedConfig.nested[1].collectionItemIndex).toBe(1);
            expect(nestedConfig.nested[2].name).toBe('subNestedOption');
            expect(nestedConfig.nested[2].options).toEqual(['prop1', 'prop2', 'sampleProp']);
            expect(nestedConfig.nested[2].initialValues).toEqual({ prop2: 'def' });
            expect(nestedConfig.nested[2].isCollectionItem).toBeTruthy();
            expect(nestedConfig.nested[2].collectionItemIndex).toBe(2);
        });
        describe('expectedChildren', function () {
            it('initialized for widget component', function () {
                var expected = {};
                var WidgetComponent = createComponent({
                    beforeCreate: function () {
                        this.$_WidgetClass = WidgetClass;
                        this.$_expectedChildren = expected;
                    },
                });
                var wrapper = mount(WidgetComponent);
                expect(wrapper.vm.$_config.expectedChildren).toBe(expected);
            });
            it('initialized for config component', function () {
                var expected = {};
                var ConfigComponent = buildTestConfigCtor();
                ConfigComponent.$_optionName = 'nestedOption';
                ConfigComponent.$_expectedChildren = expected;
                var vm = defineComponent({
                    template: '<test-component id="component">'
                        + '  <config-component />'
                        + '</test-component>',
                    components: {
                        TestComponent: TestComponent,
                        ConfigComponent: ConfigComponent,
                    },
                });
                var wrapper = mount(vm);
                var widgetConfig = wrapper.getComponent('#component').vm.$_config;
                expect(widgetConfig.nested[0].expectedChildren).toBe(expected);
            });
        });
    });
    describe('nested option', function () {
        var Nested = buildTestConfigCtor();
        Nested.$_optionName = 'nestedOption';
        it('pulls initital values', function () {
            var vm = defineComponent({
                template: '<test-component id="component">'
                    + '  <nested :prop1="123" />'
                    + '</test-component>',
                components: {
                    TestComponent: TestComponent,
                    Nested: Nested,
                },
            });
            var wrapper = mount(vm);
            var component = wrapper.getComponent('#component');
            expect(WidgetClass.mock.calls[0][0]).toBe(component.vm.$el);
            expect(skipIntegrationOptions(WidgetClass.mock.calls[0][1])).toEqual({
                nestedOption: {
                    prop1: 123,
                },
                templatesRenderAsynchronously: true,
            });
        });
        it('watches option changes', function (done) {
            var vm = defineComponent({
                template: '<test-component>'
                    + '  <nested :prop1="value" />'
                    + '</test-component>',
                components: {
                    TestComponent: TestComponent,
                    Nested: Nested,
                },
                props: ['value'],
            });
            var wrapper = mount(vm, {
                props: {
                    value: 123,
                },
            });
            wrapper.setProps({ value: 456 });
            nextTick(function () {
                expect(Widget.option).toHaveBeenCalledTimes(1);
                expect(Widget.option).toHaveBeenCalledWith('nestedOption.prop1', 456);
                done();
            });
        });
        it('add nested component by condition', function (done) {
            var vm = defineComponent({
                template: '<test-component>'
                    + '  <nested v-if="showNest" :prop1="123" />'
                    + '</test-component>',
                components: {
                    TestComponent: TestComponent,
                    Nested: Nested,
                },
                props: {
                    showNest: {
                        type: Boolean,
                        value: false,
                    },
                },
            });
            var wrapper = mount(vm);
            wrapper.setProps({ showNest: true });
            nextTick(function () {
                expect(Widget.option).toHaveBeenCalledWith('nestedOption', { key: 0, prop1: 123 });
                done();
            });
        });
        it('remove nested component by condition', function (done) {
            var NestedCollectionItem = buildTestConfigCtor();
            NestedCollectionItem.$_optionName = 'nestedOption';
            NestedCollectionItem.$_isCollectionItem = true;
            var vm = defineComponent({
                template: '<test-component>'
                    + '  <nested-collection-item v-if="show" :prop1="123" />'
                    + '  <nested-collection-item :prop1="321" />'
                    + '</test-component>',
                components: {
                    TestComponent: TestComponent,
                    NestedCollectionItem: NestedCollectionItem,
                },
                props: {
                    show: {
                        type: Boolean,
                        default: true,
                    },
                },
            });
            var wrapper = mount(vm);
            wrapper.setProps({ show: false });
            nextTick(function () {
                expect(Widget.option).toHaveBeenCalledWith('nestedOption', [{ prop1: 321 }]);
                done();
            });
        });
        it('should update only part of collection components', function (done) {
            var NestedCollectionItem = buildTestConfigCtor();
            NestedCollectionItem.$_optionName = 'nestedOption';
            NestedCollectionItem.$_isCollectionItem = true;
            var vm = defineComponent({
                template: '<test-component>'
                    + '  <nested-collection-item>'
                    + '     <nested-collection-item>'
                    + '       <nested-collection-item v-if="show" :prop1="123">'
                    + '       </nested-collection-item>'
                    + '       <nested-collection-item :prop1="321">'
                    + '       </nested-collection-item>'
                    + '     </nested-collection-item>'
                    + '  </nested-collection-item>'
                    + '</test-component>',
                components: {
                    TestComponent: TestComponent,
                    NestedCollectionItem: NestedCollectionItem,
                },
                props: {
                    show: {
                        type: Boolean,
                        default: true,
                    },
                },
            });
            var wrapper = mount(vm);
            wrapper.setProps({ show: false });
            nextTick(function () {
                expect(Widget.option)
                    .toHaveBeenCalledWith('nestedOption[0].nestedOption[0].nestedOption', [{ prop1: 321 }]);
                done();
            });
        });
        it('should update only part of collection components (remove all subnested)', function (done) {
            var NestedCollectionItem = buildTestConfigCtor();
            NestedCollectionItem.$_optionName = 'nestedOption';
            NestedCollectionItem.$_isCollectionItem = true;
            var vm = defineComponent({
                template: '<test-component>'
                    + '  <nested-collection-item>'
                    + '     <nested-collection-item>'
                    + '       <nested-collection-item v-if="show" :prop1="123">'
                    + '       </nested-collection-item>'
                    + '       <nested-collection-item v-if="show" :prop1="321">'
                    + '       </nested-collection-item>'
                    + '     </nested-collection-item>'
                    + '  </nested-collection-item>'
                    + '</test-component>',
                components: {
                    TestComponent: TestComponent,
                    NestedCollectionItem: NestedCollectionItem,
                },
                props: {
                    show: {
                        type: Boolean,
                        default: true,
                    },
                },
            });
            var wrapper = mount(vm);
            wrapper.setProps({ show: false });
            nextTick(function () {
                expect(Widget.option).toHaveBeenCalledWith('nestedOption[0].nestedOption[0].nestedOption', undefined);
                done();
            });
        });
        it('reset nested component', function (done) {
            var vm = defineComponent({
                template: '<test-component>'
                    + '  <nested v-if="show" :prop1="123" />'
                    + '</test-component>',
                components: {
                    TestComponent: TestComponent,
                    Nested: Nested,
                },
                props: {
                    show: {
                        type: Boolean,
                        default: true,
                    },
                },
            });
            var wrapper = mount(vm);
            wrapper.setProps({ show: false });
            nextTick(function () {
                expect(Widget.resetOption).toHaveBeenCalledWith('nestedOption');
                done();
            });
        });
    });
    function renderTemplate(name, model, container, index) {
        model = model || {};
        container = container || document.createElement('div');
        var render = WidgetClass.mock.calls[0][1].integrationOptions.templates[name].render;
        return render({
            container: container,
            model: model,
            index: index,
        });
    }
    describe('template', function () {
        var DX_TEMPLATE_WRAPPER = 'dx-template-wrapper';
        var componentWithTemplate = defineComponent({
            template: "<test-component :prop1='prop1Value'>\n                         <template #test v-if='renderTemplate'>content</template>\n                       </test-component>",
            components: {
                TestComponent: TestComponent,
            },
            props: {
                renderTemplate: {
                    type: Boolean,
                    value: false,
                },
                prop1Value: {
                    type: Number,
                    value: 1,
                },
            },
        });
        function renderItemTemplate(model, container, index) {
            return renderTemplate('item', model, container, index);
        }
        it('passes integrationOptions to widget', function () {
            var vm = defineComponent({
                template: "<test-component>\n                             <template #item>\n                               <div>1</div>\n                             </template>\n                             <template #content>\n                               <div>1</div>\n                             </template>\n                             <div>1</div>\n                           </test-component>",
                components: {
                    TestComponent: TestComponent,
                },
            });
            mount(vm);
            var integrationOptions = WidgetClass.mock.calls[0][1].integrationOptions;
            expect(integrationOptions).toBeDefined();
            expect(integrationOptions.templates).toBeDefined();
            expect(integrationOptions.templates.item).toBeDefined();
            expect(typeof integrationOptions.templates.item.render).toBe('function');
            expect(integrationOptions.templates.content).toBeDefined();
            expect(typeof integrationOptions.templates.content.render).toBe('function');
            expect(integrationOptions.templates.default).toBeUndefined();
        });
        it('pass correct template name', function () {
            var vm = defineComponent({
                template: "<test-component templateName=\"myTemplate\">\n                             <template #item>\n                               <div>1</div>\n                             </template>\n                             <template #content>\n                               <div>1</div>\n                             </template>\n                             <div>1</div>\n                           </test-component>",
                components: {
                    TestComponent: TestComponent,
                },
            });
            mount(vm);
            var integrationOptions = WidgetClass.mock.calls[0][1].integrationOptions;
            expect(integrationOptions).toBeDefined();
            expect(integrationOptions.templates).toBeDefined();
            expect(integrationOptions.templates.item).toBeDefined();
            expect(typeof integrationOptions.templates.item.render).toBe('function');
            expect(integrationOptions.templates.content).toBeDefined();
            expect(typeof integrationOptions.templates.content.render).toBe('function');
            expect(integrationOptions.templates.default).toBeUndefined();
        });
        it('passes \'integrationOptions.templates\' on update', function () {
            var wrapper = mount(componentWithTemplate);
            wrapper.setProps({
                renderTemplate: true,
            });
            nextTick(function () {
                expect(Widget.option.mock.calls[0][0]).toEqual('integrationOptions.templates');
                expect(Widget.option.mock.calls[0][1].test.render).toBeInstanceOf(Function);
            });
        });
        it('passes \'integrationOptions.templates\' on update before other options', function () {
            var wrapper = mount(componentWithTemplate);
            wrapper.setProps({
                renderTemplate: true,
                prop1Value: 2,
            });
            nextTick(function () {
                expect(Widget.option.mock.calls[0][0]).toEqual('integrationOptions.templates');
                expect(Widget.option.mock.calls[1]).toEqual(['test', 'test']);
                expect(Widget.option.mock.calls[2]).toEqual(['prop1', 2]);
            });
        });
        describe('with DOM', function () {
            var fixture;
            beforeEach(function () {
                fixture = document.createElement('div');
                fixture.id = 'fixture';
                document.body.appendChild(fixture);
            });
            afterEach(function () {
                fixture.remove();
            });
            it('template content should be rendered in DOM', function () {
                var mountedInDom;
                var ChildComponent = defineComponent({
                    template: '<div>Test</div>',
                    mounted: function () {
                        mountedInDom = document.body.contains(this.$el);
                    },
                });
                var instance = defineComponent({
                    template: "<test-component id=\"component\">\n                                    <div class=\"template-container\"></div>\n                                    <template #tmpl>\n                                        <child-component/>\n                                    </template>\n                                </test-component>",
                    components: {
                        TestComponent: TestComponent,
                        ChildComponent: ChildComponent,
                    },
                });
                var wrapper = mount(instance, { attachTo: document.getElementById('fixture') });
                renderTemplate('tmpl', {}, wrapper.getComponent('#component').vm.$el.querySelector('.template-container'));
                expect(mountedInDom).toBeTruthy();
            });
        });
        it('does not unnecessarily pass \'integrationOptions.templates\'', function () {
            var wrapper = mount(componentWithTemplate, {
                props: {
                    renderTemplate: true,
                    prop1Value: 1,
                },
            });
            wrapper.setProps({
                prop1Value: 2,
            });
            wrapper.setProps({
                prop1Value: 3,
            });
            expect(Widget.option.mock.calls.find(function (call) { return call[0] === 'integrationOptions.templates'; })).toBeUndefined();
        });
        it('renders', function () {
            var vm = defineComponent({
                template: "<test-component>\n                                <template #item>\n                                    <div>Template</div>\n                                </template>\n                            </test-component>",
                components: {
                    TestComponent: TestComponent,
                },
            });
            mount(vm);
            var renderedTemplate = renderItemTemplate();
            expect(renderedTemplate.nodeName).toBe('DIV');
            expect(renderedTemplate.className).toBe(DX_TEMPLATE_WRAPPER);
            expect(renderedTemplate.innerHTML).toBe('Template');
        });
        it('renders template with several children', function () {
            var vm = defineComponent({
                template: "<test-component>\n                                <template #item>\n                                    <div>child1</div>\n                                    <div>child2</div>\n                                </template>\n                            </test-component>",
                components: {
                    TestComponent: TestComponent,
                },
            });
            mount(vm);
            var container = document.createElement('div');
            renderItemTemplate({}, container);
            expect(container.innerHTML).toBe('<div>child1</div><div>child2</div><span style="display: none;"></span>');
        });
        it('template should have globalProperties of parent', function () {
            var templateGlobalProperties;
            var CustomComponent = defineComponent({
                template: '<div></div>',
                mounted: function () {
                    templateGlobalProperties = this.$.appContext.config.globalProperties;
                },
            });
            var vm = defineComponent({
                template: "<test-component id=\"component\">\n                                <template #item>\n                                    <CustomComponent></CustomComponent>\n                                </template>\n                            </test-component>",
                components: {
                    TestComponent: TestComponent,
                    CustomComponent: CustomComponent,
                },
            });
            var config = {
                globalProperties: { name: 'test' },
            };
            // @ts-expect-error
            mount(vm, { global: { config: config } });
            renderItemTemplate();
            expect(templateGlobalProperties).toEqual(config.globalProperties);
        });
        it('template should have custom plugins data', function () {
            var testData;
            var CustomComponent = defineComponent({
                template: '<div></div>',
                mounted: function () {
                    testData = this.$.appContext.app.test;
                },
            });
            var vm = defineComponent({
                template: "<test-component id=\"component\">\n                                <template #item>\n                                    <CustomComponent></CustomComponent>\n                                </template>\n                            </test-component>",
                components: {
                    TestComponent: TestComponent,
                    CustomComponent: CustomComponent,
                },
            });
            mount(vm, {
                global: {
                    plugins: [CustomPlugin],
                },
            });
            renderItemTemplate();
            expect(testData).toEqual('test data');
        });
        it('template should have router provides of parent', function () {
            var router = createRouter({
                history: createWebHistory(),
                routes: [],
            });
            var templateProvides;
            var CustomComponent = defineComponent({
                template: '<div></div>',
                mounted: function () {
                    templateProvides = this.$.appContext.provides;
                },
            });
            var vm = defineComponent({
                template: "<test-component id=\"component\">\n                                <template #item>\n                                    <CustomComponent></CustomComponent>\n                                </template>\n                            </test-component>",
                components: {
                    TestComponent: TestComponent,
                    CustomComponent: CustomComponent,
                },
            });
            mount(vm, {
                global: {
                    plugins: [router],
                },
            });
            renderItemTemplate();
            expect(Object.getOwnPropertySymbols(templateProvides)).toHaveLength(3);
        });
        it('renders scoped slot', function () {
            var vm = defineComponent({
                template: "<test-component>\n                                <template #item=\"{ data: { text }, index }\">\n                                    Template {{text}} and index {{index}}\n                                </template>\n                            </test-component>",
                components: {
                    TestComponent: TestComponent,
                },
            });
            mount(vm);
            var renderedTemplate = renderItemTemplate({ text: 'with data' }, undefined, 5);
            expect(renderedTemplate.textContent).toContain('Template with data and index 5');
        });
        it('unwraps container', function () {
            var vm = defineComponent({
                template: "<test-component>\n                                <template #item=\"{ data }\">\n                                    <div>Template {{data.text}}</div>\n                                </template>\n                            </test-component>",
                components: {
                    TestComponent: TestComponent,
                },
            });
            mount(vm);
            var renderedTemplate = renderItemTemplate({ text: 'with data' }, { get: function () { return document.createElement('div'); } });
            expect(renderedTemplate.nodeName).toBe('DIV');
            expect(renderedTemplate.innerHTML).toBe('Template with data');
        });
        it('preserves classes', function () {
            var vm = defineComponent({
                template: "<test-component>\n                                <template #item=\"{ data }\">\n                                    <div class='custom-class'></div>\n                                </template>\n                            </test-component>",
                components: {
                    TestComponent: TestComponent,
                },
            });
            mount(vm);
            var renderedTemplate = renderItemTemplate({});
            expect(renderedTemplate.className).toBe("custom-class " + DX_TEMPLATE_WRAPPER);
        });
        it('preserves custom-attrs', function () {
            var vm = defineComponent({
                template: "<test-component>\n                                <template #item=\"{ data: { text } }\">\n                                    <div custom-attr=123>Template {{text}}</div>\n                                </template>\n                            </test-component>",
                components: {
                    TestComponent: TestComponent,
                },
            });
            mount(vm);
            var renderedTemplate = renderItemTemplate({});
            expect(renderedTemplate.attributes).toHaveProperty('custom-attr');
            expect(renderedTemplate.attributes['custom-attr'].value).toBe('123');
        });
        it('doesn\'t throw on dxremove', function () {
            var vm = defineComponent({
                template: "<test-component>\n                                <template #item=\"{ data: { text } }\">\n                                    Template {{text}}\n                                </template>\n                            </test-component>",
                components: {
                    TestComponent: TestComponent,
                },
            });
            mount(vm);
            var renderedTemplate = renderItemTemplate({ text: 'with data' });
            expect(function () { return events.triggerHandler(renderedTemplate, 'dxremove'); }).not.toThrow();
        });
        it('destroyed component should remove subscriptions', function (done) {
            var vm = defineComponent({
                template: "<test-component id=\"component\" :prop1=\"value\">\n                                <template #item=\"{data}\">Template {{data.text}}</template>\n                            </test-component>",
                components: {
                    TestComponent: TestComponent,
                },
                props: ['value'],
            });
            var wrapper = mount(vm, {
                props: {
                    value: 123,
                },
            });
            var container = document.createElement('div');
            renderItemTemplate({ text: 'with data' }, container);
            events.triggerHandler(container.children[0], 'dxremove');
            renderItemTemplate({ text: 'with data' }, container);
            var subscriptions = wrapper.getComponent('#component').vm.eventBus._list;
            expect(subscriptions.length).toBe(1);
            done();
        });
        describe('static items', function () {
            it('passes integrationOptions to widget', function () {
                var NestedItem = createConfigurationComponent({
                    props: {
                        prop1: Number,
                        template: String,
                    },
                });
                NestedItem.$_optionName = 'items';
                NestedItem.$_isCollectionItem = true;
                var vm = defineComponent({
                    template: "<test-component>\n                                <nested-item>\n                                    <template #default>\n                                        <div>1</div>\n                                    </template>\n                                </nested-item>\n                            </test-component>",
                    components: {
                        TestComponent: TestComponent,
                        NestedItem: NestedItem,
                    },
                });
                mount(vm);
                var integrationOptions = WidgetClass.mock.calls[0][1].integrationOptions;
                expect(integrationOptions).toBeDefined();
                expect(integrationOptions.templates).toBeDefined();
                expect(integrationOptions.templates['items[0].template']).toBeDefined();
                expect(typeof integrationOptions.templates['items[0].template'].render).toBe('function');
            });
            it('passes configuration component updates before templates', function () {
                var NestedItem = createConfigurationComponent({
                    props: {
                        template: String,
                    },
                });
                NestedItem.$_optionName = 'items';
                NestedItem.$_isCollectionItem = true;
                var component = defineComponent({
                    template: "<test-component :prop1='prop1Value'>\n                                <nested-item v-if=\"renderTemplate\">\n                                    <template #default>\n                                        <div>1</div>\n                                    </template>\n                                </nested-item>\n                            </test-component>",
                    components: {
                        TestComponent: TestComponent,
                        NestedItem: NestedItem,
                    },
                    props: {
                        renderTemplate: {
                            type: Boolean,
                            value: false,
                        },
                        prop1Value: {
                            type: Number,
                            value: 1,
                        },
                    },
                });
                var wrapper = mount(component);
                wrapper.setProps({
                    renderTemplate: true,
                    prop1Value: 2,
                });
                nextTick(function () {
                    expect(Widget.option.mock.calls[0][0]).toEqual('items');
                    expect(Widget.option.mock.calls[1][0]).toEqual('integrationOptions.templates');
                    expect(Widget.option.mock.calls[2][0]).toEqual('items[0].template');
                    expect(Widget.option.mock.calls[3][0]).toEqual('prop1');
                });
            });
            it('passes node of nested component as template', function () {
                var NestedItem = createConfigurationComponent({
                    props: {
                        prop1: Number,
                        template: String,
                    },
                });
                NestedItem.$_optionName = 'items';
                NestedItem.$_isCollectionItem = true;
                var vm = defineComponent({
                    template: "<test-component>\n                                <nested-item>\n                                    <div>1</div>\n                                </nested-item>\n                            </test-component>",
                    components: {
                        TestComponent: TestComponent,
                        NestedItem: NestedItem,
                    },
                });
                mount(vm);
                var integrationOptions = WidgetClass.mock.calls[0][1].integrationOptions;
                expect(integrationOptions.templates['items[0].template']).toBeDefined();
                expect(typeof integrationOptions.templates['items[0].template'].render).toBe('function');
            });
            it('passes node of nested component as template (exclude nested component)', function () {
                var NestedItem = createConfigurationComponent({
                    props: {
                        prop1: Number,
                        template: String,
                    },
                });
                NestedItem.$_optionName = 'items';
                NestedItem.$_isCollectionItem = true;
                var vm = defineComponent({
                    template: "<test-component>\n                                <nested-item>\n                                    <nested-item></nested-item>\n                                    <div>1</div>\n                                </nested-item>\n                            </test-component>",
                    components: {
                        TestComponent: TestComponent,
                        NestedItem: NestedItem,
                    },
                });
                mount(vm);
                var integrationOptions = WidgetClass.mock.calls[0][1].integrationOptions;
                expect(integrationOptions.templates['items[0].template']).toBeDefined();
                expect(typeof integrationOptions.templates['items[0].template'].render).toBe('function');
            });
            it('passes node of nested component as template (tree of components)', function () {
                var NestedItem = createConfigurationComponent({
                    props: {
                        prop1: Number,
                        template: String,
                    },
                });
                NestedItem.$_optionName = 'items';
                NestedItem.$_isCollectionItem = true;
                var vm = defineComponent({
                    template: "<test-component>\n                                <nested-item>\n                                    <nested-item>\n                                        <div>1</div>\n                                    </nested-item>\n                                    <div>1</div>\n                                </nested-item>\n                            </test-component>",
                    components: {
                        TestComponent: TestComponent,
                        NestedItem: NestedItem,
                    },
                });
                mount(vm);
                var integrationOptions = WidgetClass.mock.calls[0][1].integrationOptions;
                expect(integrationOptions.templates['items[0].template']).toBeDefined();
                expect(typeof integrationOptions.templates['items[0].template'].render).toBe('function');
                expect(integrationOptions.templates['items[0].items[0].template']).toBeDefined();
                expect(typeof integrationOptions.templates['items[0].items[0].template'].render).toBe('function');
            });
            it('doesn\'t pass integrationOptions to widget if template prop is absent', function () {
                var NestedItem = createConfigurationComponent({
                    props: {
                        prop1: Number,
                    },
                });
                NestedItem.$_optionName = 'items';
                NestedItem.$_isCollectionItem = true;
                var vm = defineComponent({
                    template: "<test-component>\n                                <nested-item>\n                                    <div>1</div>\n                                </nested-item>\n                            </test-component>",
                    components: {
                        TestComponent: TestComponent,
                        NestedItem: NestedItem,
                    },
                });
                mount(vm);
                var integrationOptions = WidgetClass.mock.calls[0][1].integrationOptions;
                expect(integrationOptions).toBeDefined();
                expect(integrationOptions.templates).toBeUndefined();
            });
            it('renders template containing text only (vue 3)', function () {
                var NestedItem = createConfigurationComponent({
                    props: {
                        prop1: Number,
                        template: String,
                    },
                });
                NestedItem.$_optionName = 'item';
                var wrapper = defineComponent({
                    template: "<test-component>\n                                <nested-item>\n                                    <template #default>abc</template>\n                                </nested-item>\n                            </test-component>",
                    components: {
                        TestComponent: TestComponent,
                        NestedItem: NestedItem,
                    },
                });
                mount(wrapper);
                var renderedTemplate = renderTemplate('item.template');
                expect(renderedTemplate.textContent).toBe('abc');
            });
            it('doesn\'t pass template to integrationOptions if nested item has hidden sub nested item', function () {
                var NestedItem = createConfigurationComponent({
                    props: {
                        prop1: Number,
                        template: String,
                    },
                });
                NestedItem.$_optionName = 'items';
                NestedItem.$_isCollectionItem = true;
                var SubNested = buildTestConfigCtor();
                SubNested.$_optionName = 'subNestedOption';
                var vm = defineComponent({
                    template: "<test-component>\n                                <nested-item>\n                                    <sub-nested v-if=\"showNest\" prop2=\"abc\"/>\n                                </nested-item>\n                            </test-component>",
                    components: {
                        TestComponent: TestComponent,
                        SubNested: SubNested,
                        NestedItem: NestedItem,
                    },
                });
                mount(vm);
                expect(WidgetClass.mock.calls[0][1].integrationOptions.templates).toBeUndefined();
            });
            it('doesn\'t pass template to integrationOptions if nested item has comment', function () {
                var NestedItem = createConfigurationComponent({
                    props: {
                        prop1: Number,
                        template: String,
                    },
                });
                NestedItem.$_optionName = 'items';
                NestedItem.$_isCollectionItem = true;
                var SubNested = buildTestConfigCtor();
                SubNested.$_optionName = 'subNestedOption';
                var vm = defineComponent({
                    template: "<test-component>\n                                <nested-item>\n                                    <!-- <div>test</div> -->\n                                </nested-item>\n                            </test-component>",
                    components: {
                        TestComponent: TestComponent,
                        NestedItem: NestedItem,
                    },
                });
                mount(vm);
                expect(WidgetClass.mock.calls[0][1].integrationOptions.templates).toBeUndefined();
            });
            it('doesn\'t pass integrationOptions to widget if nested item has sub nested item', function () {
                var NestedItem = createConfigurationComponent({
                    props: {
                        prop1: Number,
                        template: String,
                    },
                });
                NestedItem.$_optionName = 'items';
                NestedItem.$_isCollectionItem = true;
                var SubNested = buildTestConfigCtor();
                SubNested.$_optionName = 'subNestedOption';
                var vm = defineComponent({
                    template: "<test-component>\n                                <nested-item>\n                                    <sub-nested prop2=\"abc\"/>\n                                </nested-item>\n                            </test-component>",
                    components: {
                        TestComponent: TestComponent,
                        SubNested: SubNested,
                        NestedItem: NestedItem,
                    },
                });
                mount(vm);
                expect(WidgetClass.mock.calls[0][1].integrationOptions.templates).toBeUndefined();
            });
        });
    });
    describe('extension component', function () {
        var ExtensionWidgetClass = jest.fn(createWidget);
        var TestExtensionComponent = createExtensionComponent({
            beforeCreate: function () {
                this.$_WidgetClass = ExtensionWidgetClass;
            },
            props: {
                prop: Array,
            },
        });
        it('renders once if mounted manually and targets self element', function () {
            var component = mount(TestExtensionComponent);
            var expectedElement = component.vm.$el;
            var actualElement = ExtensionWidgetClass.mock.calls[0][0];
            expect(ExtensionWidgetClass).toHaveBeenCalledTimes(1);
            expect(actualElement).toBe(expectedElement);
        });
        it('renders once without parent element and targets self element', function () {
            var vm = defineComponent({
                template: '<test-extension-component id="component" />',
                components: {
                    TestExtensionComponent: TestExtensionComponent,
                },
            });
            var wrapper = mount(vm);
            var expectedElement = wrapper.getComponent('#component').vm.$el;
            var actualElement = ExtensionWidgetClass.mock.calls[0][0];
            expect(ExtensionWidgetClass).toHaveBeenCalledTimes(1);
            expect(actualElement).toBe(expectedElement);
        });
        it('renders once inside component and targets parent element', function () {
            var vm = defineComponent({
                template: "<test-component id=\"component\">\n                                <test-extension-component/>\n                            </test-component>",
                components: {
                    TestComponent: TestComponent,
                    TestExtensionComponent: TestExtensionComponent,
                },
            });
            mount(vm);
            var expectedElement = WidgetClass.mock.calls[0][0];
            var actualElement = ExtensionWidgetClass.mock.calls[0][0];
            expect(ExtensionWidgetClass).toHaveBeenCalledTimes(1);
            expect(actualElement).toBe(expectedElement);
        });
        it('should set extension flag when component mounted', function () {
            var getExtansionFlag = function (componentInstance) { return getNodeOptions(componentInstance).$_isExtension; };
            TestExtensionComponent.created = function () {
                expect(getExtansionFlag(this)).toBeFalsy();
            };
            TestExtensionComponent.mounted = function () {
                expect(getExtansionFlag(this)).toBeTruthy();
            };
            var vm = defineComponent({
                template: "<test-component id=\"component\">\n                                <test-extension-component/>\n                            </test-component>",
                components: {
                    TestComponent: TestComponent,
                    TestExtensionComponent: TestExtensionComponent,
                },
            });
            mount(vm);
        });
        it('should create two different components', function () {
            var vm = defineComponent({
                template: "<test-component>\n                                <test-extension-component id=\"component1\" :prop=\"[{ type: 'required' }]\" />\n                            </test-component>\n                            <test-component>\n                                <test-extension-component id=\"component2\" :prop=\"[{ type: 'email' }]\" />\n                            </test-component>",
                components: {
                    TestComponent: TestComponent,
                    TestExtensionComponent: TestExtensionComponent,
                },
            });
            var wrapper = mount(vm);
            var component1 = wrapper.getComponent('#component1');
            var component2 = wrapper.getComponent('#component2');
            expect(component1.vm.$_config._initialValues.prop[0]).toEqual({ type: 'required' });
            expect(component2.vm.$_config._initialValues.prop[0]).toEqual({ type: 'email' });
        });
        it('should remove extension component from dom', function () {
            var childCount;
            WidgetClass.mockImplementationOnce(function (element, options) {
                childCount = element.childElementCount;
                return createWidget(element, options);
            });
            mount(defineComponent({
                template: "<test-component>\n                                <test-extension-component/>\n                            </test-component>",
                components: {
                    TestComponent: TestComponent,
                    TestExtensionComponent: TestExtensionComponent,
                },
            }));
            expect(childCount).toBe(0);
        });
        it('destroys correctly', function () {
            var component = mount(TestExtensionComponent);
            expect(component.unmount.bind(component)).not.toThrow();
        });
    });
});
describe('disposing', function () {
    it('call dispose', function () {
        var component = mount(TestComponent);
        component.unmount();
        expect(Widget.dispose).toBeCalled();
    });
    it('fires dxremove', function () {
        var handleDxRemove = jest.fn();
        var component = mount(TestComponent);
        events.on(component.vm.$el, 'dxremove', handleDxRemove);
        component.unmount();
        expect(handleDxRemove).toHaveBeenCalledTimes(1);
    });
    it('destroys correctly', function () {
        var component = mount(TestComponent);
        expect(component.unmount.bind(component)).not.toThrow();
    });
});
describe('children processing', function () {
    it.skip('should process children if they are wrapped to a bail container', function () {
        var Nested = buildTestConfigCtor();
        var config = new Configuration(function () { return undefined; }, null, {});
        Nested.$_optionName = 'nestedOption';
        var nestedVNode = createVNode(Nested);
        var vnode = renderSlot({ default: function () { return [nestedVNode]; } }, 'default', undefined, function () { return [h('comment')]; });
        expect(vnode.patchFlag).toBe(-2 /* BAIL */);
        pullConfigComponents([vnode], [], config);
        expect(nestedVNode).toHaveProperty('$_config');
    });
});
